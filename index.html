<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<title> ChatFisio — Layout Otimizado</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<!-- Fuse.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.basic.min.js"></script>

<style>
  :root{
    --accent:#0b3d91;        /* azul escuro principal */
    --accent-2:#0e4aa8;      /* variação */
    --bg:#eef3fb;            /* fundo claro suave */
    --card:#ffffff;
    --user:#dbeeff;
    --bot:#eef6ff;
    --muted:#47607f;
    --maxw:1100px;
    --gap:12px;
    --radius:12px;
    --shadow: 0 8px 28px rgba(11,61,145,0.08);
    --sidebar-w:320px;
  }

  /* reset & base */
  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif; background:var(--bg); color:#07203a; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  *{box-sizing:border-box}

  /* app agora ocupa toda a viewport e usa grid para layout estilo ChatGPT */
  .app{height:100vh;display:grid;grid-template-rows:auto 1fr;grid-template-columns:var(--sidebar-w) 1fr;gap:12px;align-items:start;padding:16px}

  /* quando a sidebar estiver fechada, reduzimos a grid para 1 coluna */
  .app.sidebar-closed{grid-template-columns:0 1fr}

  header{grid-column:1/-1;display:flex;align-items:center;gap:12px;padding:12px;border-radius:12px;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;box-shadow:var(--shadow);position:sticky;top:12px;z-index:50}
  header h1{margin:0;font-size:16px;line-height:1.1}
  header .top-controls{margin-left:auto;display:flex;gap:8px;align-items:center}

  .btn-icon{background:transparent;border:none;color:inherit;padding:8px;border-radius:8px;cursor:pointer;font-size:18px}
  .btn-primary{background:#fff;color:var(--accent);border:none;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
  .btn-small{background:rgba(255,255,255,0.12);color:#fff;border:none;padding:6px 8px;border-radius:8px}

  /* left sidebar (desktop) */
  aside.left{width:var(--sidebar-w);background:var(--card);border-radius:var(--radius);padding:12px;box-shadow:0 6px 18px rgba(10,10,10,0.04);display:flex;flex-direction:column;gap:8px;height:calc(100vh - 96px);overflow:auto;transition:transform .24s ease, opacity .18s ease}
  /* quando app.sidebar-closed -> esconder sidebar visualmente */
  .app.sidebar-closed aside.left{transform:translateX(-18px) scale(.99);opacity:0;pointer-events:none}

  aside.left h3{margin:0 0 8px 0;font-size:14px}
  .pop-list{display:flex;flex-direction:column;gap:8px;max-height:calc(100% - 140px);overflow:auto;padding-right:6px}
  .pop-item{padding:12px;border-radius:10px;cursor:pointer;border:1px solid transparent;font-size:15px;line-height:1.2}
  .pop-item:hover{background:#f3f8ff}
  .pop-item.active{background:linear-gradient(90deg,#f0f6ff,#e7f0ff);border-color:#d6e6ff;box-shadow:0 4px 12px rgba(11,61,145,0.04)}

  /* center chat area semelhante ao ChatGPT: painel principal com largura responsiva centrada internamente */
  main.center{display:flex;flex-direction:column;background:var(--card);border-radius:var(--radius);padding:8px;box-shadow:0 6px 18px rgba(10,10,10,0.04);min-height:calc(100vh - 128px);margin-right:8px}

  /* chat interior: restringe o conteúdo para leitura confortável e centraliza dentro do main */
  .chat-shell{flex:1;display:flex;justify-content:center;align-items:stretch;padding:12px 8px}
  .chat-window{width:100%;max-width:var(--maxw);display:flex;flex-direction:column;background:transparent}

  #chat{flex:1;overflow:auto;padding:12px 16px 120px 16px;display:flex;flex-direction:column;gap:10px;scroll-behavior:smooth;border-radius:8px}
  .msg{max-width:78%;padding:12px 14px;border-radius:12px;white-space:pre-wrap;word-break:break-word;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
  .msg.user{align-self:flex-end;background:var(--user);color:var(--accent)}
  .msg.bot{align-self:flex-start;background:var(--bot);color:#052035}
  .meta{font-size:12px;color:var(--muted);margin-top:6px}

  .input-row{display:flex;gap:8px;padding:10px;border-top:1px solid #eef4fb;background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.98));align-items:center;position:sticky;bottom:0;margin-top:8px;border-radius:10px}
  .input-row input{flex:1;padding:12px;border-radius:12px;border:1px solid #dfeaf8;font-size:16px}
  .input-row button{background:var(--accent);color:#fff;border:none;padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:700;font-size:15px;min-width:72px}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  .small-btn{display:inline-block;padding:8px 10px;border-radius:10px;border:1px solid #e6eef0;background:#fff;cursor:pointer;font-size:14px;margin-right:6px}
  footer{font-size:13px;color:var(--muted);text-align:center;padding:6px;grid-column:1/-1}

  /* mobile off-canvas aside: mantemos comportamento anterior, só tornamos animação mais suave */
  .mobile-aside{position:fixed;inset:0 auto 0 0;width:320px;max-width:86%;transform:translateX(-110%);transition:transform .24s cubic-bezier(.2,.9,.3,1);z-index:1200;margin-left:8px}
  .mobile-aside.open{transform:translateX(0)}
  .aside-backdrop{position:fixed;inset:0;background:rgba(3,12,30,0.36);z-index:1100;opacity:0;pointer-events:none;transition:opacity .18s}
  .aside-backdrop.show{opacity:1;pointer-events:auto}

  /* responsive adjustments */
  @media (max-width:1000px){
    :root{--sidebar-w:0}
    .app{grid-template-columns:0 1fr}
    .app.sidebar-closed{grid-template-columns:0 1fr}
    aside.left{position:fixed;left:8px;top:84px;bottom:12px;z-index:40}
    header{top:8px}
    main.center{min-height:calc(100vh - 124px);margin-right:0}
  }

  @media (max-width:720px){
    .app{padding:10px}
    header{padding:10px;border-radius:10px}
    .chat-shell{padding:6px}
    .input-row{position:fixed;left:0;right:0;bottom:0;padding:12px;background:linear-gradient(180deg, #ffffff, #fbfdff);box-shadow:0 -6px 20px rgba(11,61,145,0.06);z-index:1000}
    main.center{padding-bottom:88px}
    #chat{padding-bottom:140px}
    footer{display:none}
  }

  /* improved accessibility focus styles */
  .pop-item:focus{outline:2px solid rgba(11,61,145,0.18);outline-offset:2px}

</style>
</head>
<body>
  <div class="app" role="application" aria-label="Assistente POPs" id="appRoot">
    <header>
      <button class="btn-icon" id="openListBtn" title="Abrir/fechar lista de POPs" aria-label="Abrir/fechar lista de POPs">☰</button>
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none" style="flex:0 0 36px">
        <rect width="24" height="24" rx="6" fill="#fff" opacity="0.06"/>
        <path d="M7 11c1.5-2 4-3 6-3s4.5 1 6 3" stroke="#fff" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M7 16c1.5-2 4-3 6-3s4.5 1 6 3" stroke="#fff" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" opacity="0.8"/>
      </svg>
      <div style="flex:1;min-width:0">
        <h1>Chat Fisio — Desenvolvido por Rodrigo Cavalcante - Fisioterapeuta - CREFITO 2/Nº 242633-F</h1>
        <div style="font-size:13px;color:rgba(255,255,255,0.9);white-space:nowrap;overflow:hidden;text-overflow:ellipsis">Escolha um POP e faça perguntas sobre ele.</div>
      </div>
      <div class="top-controls" aria-hidden="false">
        <button class="btn-small" onclick="showAll()" title="Listar POPs">Listar</button>
        <button class="btn-primary" onclick="clearChat()" title="Limpar chat">Limpar</button>
      </div>
    </header>

    <!-- desktop aside (visível em telas maiores) -->
    <aside class="left" aria-label="Lista de POPs (desktop)" id="desktopAside">
      <h3>POPs disponíveis</h3>
      <input id="popSearch" class="pop-search" type="search" placeholder="Buscar POPs..." aria-label="Buscar POPs" />
      <div id="popCount" class="pop-count"></div>
      <div id="popList" class="pop-list" tabindex="0"></div>
      <div style="margin-top:8px">
        <button class="small-btn" onclick="resetSelection()">Trocar POP</button>
        <button class="small-btn" onclick="showAll()">Listar</button>
      </div>
    </aside>

    <!-- center area -->
    <main class="center" aria-live="polite">
      <div class="chat-shell">
        <div class="chat-window">
          <div id="chat" role="log" aria-live="polite"></div>

          <div class="input-row" role="region" aria-label="Entrada de usuário">
            <input id="input" placeholder="Digite sua pergunta (ou 'help' para comandos)..." aria-label="Pergunta do usuário" />
            <button onclick="onSend()">Enviar</button>
          </div>
          <div class="hint" style="padding:8px 6px;">Comandos: <b>trocar</b> (voltar à lista); <b>listar</b> (mostrar POPs); <b>menu</b> (abrir menu numerado do POP selecionado); <b>limpar</b> (limpar chat); <b>limpar tudo</b> (limpar chat + seleção); <b>help</b></div>
        </div>
      </div>
    </main>

  <!-- mobile off-canvas aside (mantido) -->
  <div class="mobile-aside" id="mobileAside" aria-hidden="true">
    <aside class="left" style="height:100vh;padding-top:18px;">
      <div style="display:flex;align-items:center;justify-content:space-between;padding:0 12px;">
        <h3 style="margin:0">POPs disponíveis</h3>
        <button class="btn-icon" id="closeListBtn" aria-label="Fechar lista">✕</button>
      </div>
      <input id="popSearchMobile" class="pop-search-mobile" type="search" placeholder="Buscar POPs..." aria-label="Buscar POPs (mobile)" />
      <div id="popListMobile" class="pop-list" style="padding:12px;"></div>
      <div style="padding:12px">
        <button class="small-btn" onclick="resetSelection()">Trocar POP</button>
        <button class="small-btn" onclick="showAll()">Listar</button>
      </div>
    </aside>
  </div>
  <div class="aside-backdrop" id="asideBackdrop" tabindex="-1" aria-hidden="true"></div>

<script>
/* CONFIG: troque pela URL raw do seu pops_embeddings.json OU deixe 'pops_embeddings.json' local */
const popFile = "https://raw.githubusercontent.com/Rcs1992/chatfisio/refs/heads/main/pops_embeddings.json"; // NÃO ALTERAR

let pops = [];              // array de POP objects
let popSelecionado = null;
let searchable = [];        // array usado pelo Fuse
let fuse = null;            // Fuse instance
let popFilter = "";         // filtro para lista de POPs

const appRoot = document.getElementById('appRoot');
const desktopAside = document.getElementById('desktopAside');

// ---------- utils ----------
function normalizeText(s){
  if(!s) return "";
  return s.toString()
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"") // remove acentos
    .replace(/[^\w\s\-\/\.\%]/g," ") // remove pontuação (mantém / - . %)
    .replace(/\s+/g," ").trim()
    .toLowerCase();
}
function tokenize(s){ return normalizeText(s).split(/\s+/).filter(Boolean); }

// escape HTML simples (previne XSS)
function escapeHtml(str){
  if(str == null) return "";
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function addMessage(text, who='bot', meta=null){
  const chat = document.getElementById('chat');
  const d = document.createElement('div');
  d.className = 'msg ' + (who==='user'?'user':'bot');

  const safe = escapeHtml(text).replace(/\n/g, "<br>");
  d.innerHTML = safe;
  chat.appendChild(d);

  if(meta){
    const m = document.createElement('div');
    m.className = 'meta';
    m.textContent = meta;
    chat.appendChild(m);
  }

  chat.scrollTop = chat.scrollHeight;
  const input = document.getElementById('input');
  if(input) input.focus();
}

function clearChat(){
  const chat = document.getElementById('chat');
  if(chat) chat.innerHTML = '';
  // fechar menu e painel mobile por segurança
  try { closeMenu(); } catch(e) {}
  try { closeMobileAside(); } catch(e) {}
  // manter foco para digitação
  const input = document.getElementById('input');
  if(input) {
    input.focus();
  }
}
// ---------- end utils ----------

// debounce util
function debounce(fn, wait = 200){
  let t;
  return function(...args){
    clearTimeout(t);
    t = setTimeout(()=> fn.apply(this, args), wait);
  };
}

// destaque simples por palavra (usado na renderização de títulos)
function highlightTitle(title, query){
  if(!query) return escapeHtml(title);
  const qNorm = normalizeText(query);
  const parts = title.split(/\s+/);
  const out = parts.map(w => {
    const wNorm = normalizeText(w);
    if(wNorm.includes(qNorm)){
      return `<mark style="background:rgba(11,61,145,0.12);padding:2px 4px;border-radius:6px">${escapeHtml(w)}</mark>`;
    } else {
      return escapeHtml(w);
    }
  });
  return out.join(' ');
}

// ---------- construir índice Fuse ----------
function buildSearchableIndex(){
  searchable = [];
  pops.forEach((p, pi) => {
    (p.chunks || []).forEach((ch, ci) => {
      searchable.push({
        popIndex: pi,
        chunkIndex: ci,
        titulo: p.titulo || p.title || "",
        texto: ch.texto || ch.text || "",
        keywords: (ch.keywords || []).join(" ")
      });
    });
  });

  const fuseOptions = {
    keys: [
      { name: 'texto', weight: 0.7 },
      { name: 'titulo', weight: 0.2 },
      { name: 'keywords', weight: 0.1 }
    ],
    includeScore: true,
    threshold: 0.36,
    ignoreLocation: true,
    minMatchCharLength: 2,
    useExtendedSearch: false
  };

  try{
    fuse = new Fuse(searchable, fuseOptions);
  }catch(err){
    console.error("Erro criando Fuse:", err);
    fuse = null;
  }
}

// ---------- carregar POPs ----------
async function carregarPOPs(){
  try{
    addMessage("Carregando POPs...", "bot");
    const controller = new AbortController();
    const id = setTimeout(()=> controller.abort(), 10000);
    const r = await fetch(popFile, { signal: controller.signal });
    clearTimeout(id);

    if(!r.ok) throw new Error("Erro carregando JSON: " + r.status);
    const data = await r.json();
    if(!Array.isArray(data)) throw new Error("JSON inválido: deve ser um array de POPs");
    pops = data;

    for(const p of pops){
      p.titulo = p.titulo || p.title || "Sem título";
      p._normTitulo = normalizeText(p.titulo);
      for(const ch of (p.chunks || [])){
        ch.texto = ch.texto || ch.text || "";
        ch._normText = normalizeText(ch.texto);
        const toks = tokenize(ch._normText);
        ch._tokens = toks;
        ch._tokenSet = new Set(toks);
        ch._normKeywords = (ch.keywords||[]).map(k => normalizeText(k));
      }
    }

    buildSearchableIndex();

    renderPopList();
    addMessage("POPs carregados. Selecione um POP à esquerda (clique ou digite o número).", "bot");
  }catch(err){
    console.error(err);
    addMessage("Erro ao carregar POPs: " + (err.message||err), "bot");
  }
}

// render list (desktop + mobile)
function renderPopList(){
  const list = document.getElementById('popList');
  const listMobile = document.getElementById('popListMobile');
  const countEl = document.getElementById('popCount');
  if(list) list.innerHTML = '';
  if(listMobile) listMobile.innerHTML = '';

  const qNorm = normalizeText(popFilter);
  let shown = 0;
  pops.forEach((p,i)=>{
    const titleNorm = p._normTitulo || normalizeText(p.titulo || p.title || "");
    if(qNorm && !titleNorm.includes(qNorm)){
      return;
    }
    shown++;

    const html = `<strong>${i+1}. ${highlightTitle(p.titulo, popFilter)}</strong>`;
    const btn = document.createElement('div');
    btn.className = 'pop-item' + ((popSelecionado && popSelecionado === p) ? ' active' : '');
    btn.tabIndex = 0;
    btn.innerHTML = html;
    btn.onclick = ()=> selectPopByIndex(i);
    btn.onkeypress = (e)=>{ if(e.key==='Enter') selectPopByIndex(i); };
    if(list) list.appendChild(btn);

    const btnM = btn.cloneNode(true);
    btnM.onclick = ()=> { selectPopByIndex(i); closeMobileAside(); };
    btnM.onkeypress = (e)=>{ if(e.key==='Enter'){ selectPopByIndex(i); closeMobileAside(); } };
    if(listMobile) listMobile.appendChild(btnM);
  });

  if(countEl) countEl.textContent = `${shown} de ${pops.length} POPs`;
}

// select pop
function selectPopByIndex(i){
  popSelecionado = pops[i];
  renderPopList();
  addMessage(`📄 Você selecionou: ${popSelecionado.titulo}\nAgora pode fazer suas perguntas.`, "bot");
}

// reset selection
function resetSelection(){
  popSelecionado = null;
  renderPopList();
  addMessage("Seleção removida. Digite o número do POP ou clique no título à esquerda.", "bot");
}

// show all list again
function showAll(){
  renderPopList();
  const names = pops.map((p,i)=> `${i+1}. ${p.titulo}`).join("\n");
  addMessage(`POPs disponíveis (${pops.length}):\n\n` + names, "bot");
}

// old token-overlap search (fallback)
function searchInSelectedPOP_old(query){
  if(!popSelecionado) return {score:0, chunk:null};

  const qNorm = normalizeText(query);
  const qTokens = tokenize(qNorm);
  if(qTokens.length===0) return {score:0};

  let best = {score:0, chunk:null};
  for(const ch of popSelecionado.chunks || []){
    let score = 0;
    for(const kw of ch._normKeywords || []){
      if(qNorm.includes(kw) || kw.includes(qNorm) || qTokens.includes(kw)) score += 3;
    }
    let overlap = 0;
    for(const t of qTokens){
      if(ch._tokens.includes(t)) overlap++;
      else {
        for(const ct of ch._tokens){
          if(ct.includes(t) || t.includes(ct)){ overlap += 0.6; break; }
        }
      }
    }
    score += overlap;
    if(ch._normText.includes(qNorm)) score += 1.2;
    if(popSelecionado._normTitulo && popSelecionado._normTitulo.includes(qNorm)) score += 0.8;
    if(score > best.score){
      best = {score, chunk:ch};
    }
  }
  return best;
}

// fuzzy search via Fuse.js (retorna topK resultados apenas para o popIndex selecionado)
function searchFuzzy(query, popIndex, topK = 3){
  if(!fuse || !query) return [];
  const candidateLimit = 50;
  try{
    const results = fuse.search(query, { limit: candidateLimit });
    const filtered = results
      .map(r => ({ item: r.item, score: r.score }))
      .filter(r => r.item.popIndex === popIndex)
      .slice(0, topK)
      .map(r => ({
        popIndex: r.item.popIndex,
        chunkIndex: r.item.chunkIndex,
        texto: r.item.texto,
        titulo: r.item.titulo,
        relevance: 1 - (r.score || 0)
      }));
    return filtered;
  }catch(err){
    console.error("Erro na busca Fuse:", err);
    return [];
  }
}

// ---------- Menu por parágrafo (números) ----------
let menuOpen = false;
let menuPopIndex = null;

function getChunkTitle(chunk, idx){
  if(chunk.heading) return String(chunk.heading);
  if(chunk.title_chunk) return String(chunk.title_chunk);
  if(Array.isArray(chunk.keywords) && chunk.keywords.length){
    const k = String(chunk.keywords[0]).trim();
    if(k) return k.charAt(0).toUpperCase() + k.slice(1);
  }
  if(chunk.texto){
    const m = chunk.texto.trim().match(/^([A-ZÀ-Ú][^:\n]{2,60}):/i);
    if(m && m[1]) return m[1].trim();
  }
  const t = (chunk.texto || "").trim().split(/\s+/).slice(0,6).join(" ");
  return t ? (t + ( (chunk.texto && chunk.texto.length > t.length) ? "…" : "")) : `Parágrafo ${idx+1}`;
}

function addBotNode(node){
  const chat = document.getElementById('chat');
  const wrapper = document.createElement('div');
  wrapper.className = 'msg bot';
  wrapper.appendChild(node);
  chat.appendChild(wrapper);
  chat.scrollTop = chat.scrollHeight;
}

function showMenuForSelectedPop(optAutoOpen = false){
  if(!popSelecionado) {
    addMessage("❗ Nenhum POP selecionado. Escolha um POP primeiro.", "bot");
    return;
  }
  const pi = pops.indexOf(popSelecionado);
  if(pi < 0) return;
  menuOpen = true;
  menuPopIndex = pi;

  addMessage("Escolha um número para selecionar o que deseja (ou toque no item):", "bot");

  const container = document.createElement('div');
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.gap = '6px';
  container.style.marginTop = '6px';

  const chunks = popSelecionado.chunks || [];
  for(let i=0;i<chunks.length;i++){
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'small-btn';
    btn.textContent = `${i+1}) ${ getChunkTitle(chunks[i], i) }`;
    btn.addEventListener('click', ()=> {
      displayChunk(pi, i);
      closeMenu();
    });
    container.appendChild(btn);
  }

  const closeRow = document.createElement('div');
  closeRow.style.marginTop = '8px';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'small-btn';
  closeBtn.textContent = 'Fechar menu';
  closeBtn.addEventListener('click', ()=> { closeMenu(); addMessage('Menu fechado.', 'bot'); });
  closeRow.appendChild(closeBtn);
  container.appendChild(closeRow);

  addBotNode(container);

  if(optAutoOpen){
    const firstBtn = container.querySelector('button');
    if(firstBtn) firstBtn.focus();
  }
}

function closeMenu(){
  menuOpen = false;
  menuPopIndex = null;
}

function displayChunk(popIndex, chunkIndex){
  const pop = pops[popIndex];
  if(!pop) return;
  const ch = (pop.chunks || [])[chunkIndex];
  if(!ch) {
    addMessage("Trecho não encontrado.", "bot");
    return;
  }
  const title = `${pop.titulo} — ${getChunkTitle(ch, chunkIndex)}`;
  addMessage(`📌 ${title}`, "bot");
  addMessage(ch.texto || ch.text || "(sem texto)", "bot");
  const meta = `Fonte: ${pop.titulo} — Parágrafo ${chunkIndex+1}`;
  if(meta) {
    const m = document.createElement('div');
    m.className = 'meta';
    m.textContent = meta;
    addBotNode(m);
  }
}

// handle send
async function onSend(){
  const input = document.getElementById('input');
  const text = (input.value || "").trim();
  if(!text) return;
  addMessage(text, "user");
  input.value = "";
  const cmd = text.toLowerCase().trim();
  if(cmd === 'help'){
    addMessage("Comandos:\n- Digite o número do POP (ex: 1) ou clique no nome à esquerda para selecionar.\n- 'trocar' ou 'listar' para ver/alterar POP.\n- 'menu' mostra os parágrafos numerados do POP selecionado.\n- 'limpar' (ou 'limpar tudo') para limpar o chat ou resetar seleção.", "bot");
    return;
  }
  if(cmd === 'trocar'){
    resetSelection();
    return;
  }
  if(cmd === 'listar' || cmd === 'list'){
    showAll();
    return;
  }

  if (cmd === 'limpar' || cmd === 'clear' || cmd === 'cls') {
    clearChat();
    addMessage("✔ Chat limpo.", "bot");
    return;
  }

  if (cmd === 'limpar tudo' || cmd === 'limpartudo' || cmd === 'clearall') {
    clearChat();
    resetSelection();
    closeMenu();
    closeMobileAside();
    addMessage("✔ Chat e seleção de POP removidos.", "bot");
    return;
  }

  if(cmd === 'menu'){
    if(!popSelecionado){
      addMessage("Ainda não há POP selecionado. Selecione um POP (click ou digite o número).", "bot");
      return;
    }
    showMenuForSelectedPop(true);
    return;
  }

  if(/^\d+$/.test(cmd)){
    const n = parseInt(cmd, 10);
    if(menuOpen && menuPopIndex !== null){
      const chunks = pops[menuPopIndex].chunks || [];
      if(n >=1 && n <= chunks.length){
        displayChunk(menuPopIndex, n-1);
        closeMenu();
      } else {
        addMessage(`Número inválido. Escolha entre 1 e ${chunks.length}.`, "bot");
      }
      return;
    }

    if(popSelecionado){
      const chunks = popSelecionado.chunks || [];
      if(n >=1 && n <= chunks.length){
        const pi = pops.indexOf(popSelecionado);
        displayChunk(pi, n-1);
        return;
      }
    }

    if(!popSelecionado){
      if(n >=1 && n <= pops.length){
        selectPopByIndex(n-1);
        return;
      }
    }
  }

  if(!popSelecionado){
    const asNum = parseInt(cmd);
    if(!isNaN(asNum) && asNum >=1 && asNum <= pops.length){
      selectPopByIndex(asNum-1);
      return;
    }
    const findByTitle = pops.find(p => normalizeText(p.titulo).includes(normalizeText(text)));
    if(findByTitle){
      popSelecionado = findByTitle;
      renderPopList();
      addMessage(`📄 Você selecionou: ${popSelecionado.titulo}\nAgora pode fazer suas perguntas.`, "bot");
      return;
    }
    addMessage("Ainda não há POP selecionado. Digite o número do POP desejado ou clique no título à esquerda.", "bot");
    return;
  }

  addMessage("Assistente: ... pesquisando ...", "bot");
  await new Promise(r => setTimeout(r, 180));

  const popIndex = pops.indexOf(popSelecionado);
  let fuzzyResults = [];
  try{
    fuzzyResults = searchFuzzy(text, popIndex, 3);
  }catch(e){
    console.error(e);
    fuzzyResults = [];
  }

  const chat = document.getElementById('chat');
  for(let i=chat.children.length-1;i>=0;i--){
    const el = chat.children[i];
    if(el.classList && el.classList.contains('msg') && el.classList.contains('bot') && el.textContent && el.textContent.includes('... pesquisando ...')){
      chat.removeChild(el);
      if(chat.children[i] && chat.children[i].classList && chat.children[i].classList.contains('meta')){
        chat.removeChild(chat.children[i]);
      }
      break;
    }
  }

  if(fuzzyResults && fuzzyResults.length > 0){
    let display = `🔎 Resultados fuzzy (${fuzzyResults.length}):\n\n`;
    fuzzyResults.forEach((res, idx) => {
      display += `📌 (${idx+1}) score ${(res.relevance).toFixed(2)}\n${res.texto}\n\n`;
    });
    display += `Fonte: ${popSelecionado.titulo}`;
    addMessage(display, "bot");
    return;
  }

  const resultOld = searchInSelectedPOP_old(text);
  if(resultOld && resultOld.chunk && resultOld.score > 0){
    const display = `📌 (fallback) Trecho encontrado (score ${resultOld.score.toFixed(2)}):\n\n${resultOld.chunk.texto}\n\nFonte: ${popSelecionado.titulo}`;
    addMessage(display, "bot");
  } else {
    addMessage("❌ Não há informação sobre isso neste POP. Tente reformular a pergunta ou verifique outro POP.", "bot");
  }
}

// permitir enviar mensagem ao apertar ENTER
document.getElementById('input').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    e.preventDefault(); // evita quebra de linha
    onSend();
  }
});

// mobile aside controls (mantidos)
const openListBtn = document.getElementById('openListBtn');
const closeListBtn = document.getElementById('closeListBtn');
const mobileAside = document.getElementById('mobileAside');
const asideBackdrop = document.getElementById('asideBackdrop');

function openMobileAside(){
  mobileAside.classList.add('open');
  asideBackdrop.classList.add('show');
  mobileAside.setAttribute('aria-hidden','false');
  asideBackdrop.setAttribute('aria-hidden','false');
  const first = mobileAside.querySelector('.pop-item');
  if(first) first.focus();
  const ms = document.getElementById('popSearchMobile');
  if(ms) ms.focus();
}
function closeMobileAside(){
  mobileAside.classList.remove('open');
  asideBackdrop.classList.remove('show');
  mobileAside.setAttribute('aria-hidden','true');
  asideBackdrop.setAttribute('aria-hidden','true');
  openListBtn.focus();
}

function toggleDesktopAside(){
  // alterna classe no root .app para esconder/mostrar a sidebar em desktop
  const w = window.innerWidth || document.documentElement.clientWidth;
  if(w <= 1000){
    // em telas pequenas, abra o painel mobile
    openMobileAside();
    return;
  }
  const root = document.getElementById('appRoot');
  root.classList.toggle('sidebar-closed');
  // se abrirmos a sidebar, focar o campo de busca
  if(!root.classList.contains('sidebar-closed')){
    const ds = document.getElementById('popSearch');
    if(ds) ds.focus();
  }
}

if(openListBtn) openListBtn.addEventListener('click', toggleDesktopAside);
if(closeListBtn) closeListBtn.addEventListener('click', closeMobileAside);
if(asideBackdrop) asideBackdrop.addEventListener('click', closeMobileAside);
document.addEventListener('keydown', (e) => { if(e.key === 'Escape'){ closeMobileAside(); const root = document.getElementById('appRoot'); if(root) root.classList.add('sidebar-closed'); } });

// listeners para filtro de POPs (debounced)
const desktopSearch = document.getElementById('popSearch');
const mobileSearch = document.getElementById('popSearchMobile');
if(desktopSearch){
  desktopSearch.addEventListener('input', debounce(function(e){
    popFilter = e.target.value || "";
    renderPopList();
  }, 180));
}
if(mobileSearch){
  mobileSearch.addEventListener('input', debounce(function(e){
    popFilter = e.target.value || "";
    renderPopList();
  }, 180));
}

/* init */
carregarPOPs();
</script>
</body>
</html>


